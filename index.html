<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Online Vector Editor</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/5.3.0/fabric.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            text-align: center;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        .container {
            display: flex;
        }
        .toolbar {
            margin-bottom: 10px;
        }
    </style>
</head>
<body>

    <h1>Online Vector Editor</h1>
    
    <div class="toolbar">
        <button onclick="addRectangle()">Rectangle</button>
        <button onclick="addCircle()">Circle</button>
        <button onclick="addText()">Text</button>
        <button onclick="toggleSnapToObject()">Snap to Object</button>
        <label>Grid Spacing: <input type="number" id="gridSize" value="10" min="5" max="50" step="5" onchange="updateGridSpacing()"></label>
        <button onclick="toggleGrid()">Toggle Grid</button>
        <label>Corner Radius: <input type="number" id="cornerRadius" min="0" max="50" value="0" onchange="updateCornerRadius()"></label>
        <button onclick="toggleRotationSnap()">Rotation Snap</button>
        <button onclick="alignToGrid()">Align to Grid</button>
        <button onclick="distributeEvenly()">Distribute Evenly</button>
        <button onclick="clearCanvas()">Clear</button>
    </div>

    <div class="container">
        <canvas id="editorCanvas" width="800" height="600"></canvas>
    </div>

    <script>
        const canvas = new fabric.Canvas('editorCanvas');
        let snapToObject = false;
        let rotationSnap = false;
        let gridSize = parseInt(document.getElementById("gridSize").value);

        function addRectangle() {
            const rect = new fabric.Rect({
                left: 100, top: 100, fill: "red", width: 100, height: 100,
                cornerRadius: parseInt(document.getElementById("cornerRadius").value)
            });
            canvas.add(rect);
        }

        function addCircle() {
            const circle = new fabric.Circle({
                left: 200, top: 200, fill: "blue", radius: 50
            });
            canvas.add(circle);
        }

        function addText() {
            const text = new fabric.Textbox("Type here", {
                left: 250, top: 250, fill: "black", fontSize: 24
            });
            canvas.add(text);
        }

        function toggleSnapToObject() {
            snapToObject = !snapToObject;
            if (snapToObject) {
                canvas.on("object:moving", function (e) {
                    const target = e.target;
                    canvas.getObjects().forEach(obj => {
                        if (obj === target) return;
                        const diffX = Math.abs(target.left - obj.left);
                        const diffY = Math.abs(target.top - obj.top);
                        if (diffX < 10) target.set({ left: obj.left });
                        if (diffY < 10) target.set({ top: obj.top });
                    });
                });
            } else {
                canvas.off("object:moving");
            }
        }

        function toggleRotationSnap() {
            rotationSnap = !rotationSnap;
            if (rotationSnap) {
                canvas.on("object:rotating", function (e) {
                    e.target.set({
                        angle: Math.round(e.target.angle / 15) * 15
                    });
                });
            } else {
                canvas.off("object:rotating");
            }
        }

        function updateGridSpacing() {
            gridSize = parseInt(document.getElementById("gridSize").value);
        }

        function toggleGrid() {
            canvas.clear();
            for (let i = 0; i < canvas.width; i += gridSize) {
                for (let j = 0; j < canvas.height; j += gridSize) {
                    const line = new fabric.Line([i, 0, i, canvas.height], { stroke: "#ddd", selectable: false });
                    canvas.add(line);
                    const lineH = new fabric.Line([0, j, canvas.width, j], { stroke: "#ddd", selectable: false });
                    canvas.add(lineH);
                }
            }
        }

        function updateCornerRadius() {
            const obj = canvas.getActiveObject();
            if (obj && obj.type === "rect") {
                obj.set({ rx: parseInt(document.getElementById("cornerRadius").value), ry: parseInt(document.getElementById("cornerRadius").value) });
                canvas.renderAll();
            }
        }

        function alignToGrid() {
            canvas.getObjects().forEach(obj => {
                obj.set({
                    left: Math.round(obj.left / gridSize) * gridSize,
                    top: Math.round(obj.top / gridSize) * gridSize
                });
                obj.setCoords();
            });
            canvas.renderAll();
        }

        function distributeEvenly() {
            const objects = canvas.getObjects();
            if (objects.length < 2) return;

            objects.sort((a, b) => a.left - b.left);
            let totalWidth = objects.reduce((acc, obj) => acc + obj.width, 0);
            let space = (canvas.width - totalWidth) / (objects.length - 1);

            let currentX = 0;
            objects.forEach(obj => {
                obj.set({ left: currentX });
                obj.setCoords();
                currentX += obj.width + space;
            });

            canvas.renderAll();
        }

        function clearCanvas() {
            canvas.clear();
        }
    </script>

</body>
</html>
