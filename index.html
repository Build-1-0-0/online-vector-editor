<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Online Vector Editor</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/5.3.0/fabric.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            text-align: center;
        }
        canvas {
            border: 1px solid black;
            margin-top: 10px;
        }
        .toolbar {
            margin-bottom: 10px;
        }
        .color-picker {
            display: inline-block;
        }
    </style>
</head>
<body>

    <h1>Online Vector Editor</h1>
    
    <div class="toolbar">
        <button onclick="addRectangle()">Add Rectangle</button>
        <button onclick="addCircle()">Add Circle</button>
        <input type="color" id="colorPicker" class="color-picker" value="#ff0000">
        <button onclick="deleteSelected()">Delete</button>
        <button onclick="undo()">Undo</button>
        <button onclick="redo()">Redo</button>
        <button onclick="saveSVG()">Save as SVG</button>
        <input type="file" id="uploadFile" accept=".ai,.svg" onchange="handleFileUpload(event)">
        <button onclick="clearCanvas()">Clear Canvas</button>
    </div>

    <canvas id="editorCanvas" width="800" height="600"></canvas>

    <script>
        const canvas = new fabric.Canvas('editorCanvas');
        let undoStack = [];
        let redoStack = [];

        // Save state for undo/redo
        function saveState() {
            undoStack.push(JSON.stringify(canvas));
            redoStack = []; // Clear redo stack when making a new change
        }

        function undo() {
            if (undoStack.length > 0) {
                redoStack.push(JSON.stringify(canvas));
                canvas.loadFromJSON(undoStack.pop(), canvas.renderAll.bind(canvas));
            }
        }

        function redo() {
            if (redoStack.length > 0) {
                undoStack.push(JSON.stringify(canvas));
                canvas.loadFromJSON(redoStack.pop(), canvas.renderAll.bind(canvas));
            }
        }

        // Add a rectangle with the selected color
        function addRectangle() {
            const color = document.getElementById("colorPicker").value;
            const rect = new fabric.Rect({
                left: 100,
                top: 100,
                fill: color,
                width: 100,
                height: 100
            });
            canvas.add(rect);
            saveState();
        }

        // Add a circle with the selected color
        function addCircle() {
            const color = document.getElementById("colorPicker").value;
            const circle = new fabric.Circle({
                left: 200,
                top: 200,
                fill: color,
                radius: 50
            });
            canvas.add(circle);
            saveState();
        }

        // Delete selected object
        function deleteSelected() {
            const activeObject = canvas.getActiveObject();
            if (activeObject) {
                canvas.remove(activeObject);
                saveState();
            }
        }

        // Save canvas as SVG
        function saveSVG() {
            const svgData = canvas.toSVG();
            const blob = new Blob([svgData], { type: "image/svg+xml" });
            const link = document.createElement("a");
            link.href = URL.createObjectURL(blob);
            link.download = "drawing.svg";
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }

        // Handle file upload (AI or SVG)
        async function handleFileUpload(event) {
            const file = event.target.files[0];
            if (!file) return;

            const fileType = file.name.split('.').pop().toLowerCase();

            if (fileType === "svg") {
                loadSVG(file);
            } else if (fileType === "ai") {
                convertAItoSVG(file);
            } else {
                alert("Unsupported file format! Please upload an .AI or .SVG file.");
            }
        }

        // Load an SVG file into the canvas
        function loadSVG(file) {
            const reader = new FileReader();
            reader.onload = function (e) {
                fabric.loadSVGFromString(e.target.result, function (objects, options) {
                    canvas.clear();
                    const obj = fabric.util.groupSVGElements(objects, options);
                    canvas.add(obj);
                    canvas.renderAll();
                    saveState();
                });
            };
            reader.readAsText(file);
        }

        // Convert AI file to SVG using CloudConvert API
        async function convertAItoSVG(file) {
            const apiKey = "YOUR_CLOUDCONVERT_API_KEY"; // Replace with your API key
            const formData = new FormData();
            formData.append("file", file);
            formData.append("apikey", apiKey);
            formData.append("inputformat", "ai");
            formData.append("outputformat", "svg");

            try {
                const response = await fetch("https://api.cloudconvert.com/v2/convert", {
                    method: "POST",
                    body: formData
                });

                const result = await response.json();
                if (result.data && result.data.url) {
                    fetch(result.data.url)
                        .then(res => res.text())
                        .then(svgContent => {
                            fabric.loadSVGFromString(svgContent, function (objects, options) {
                                canvas.clear();
                                const obj = fabric.util.groupSVGElements(objects, options);
                                canvas.add(obj);
                                canvas.renderAll();
                                saveState();
                            });
                        });
                } else {
                    alert("Failed to convert AI file.");
                }
            } catch (error) {
                console.error("Error converting AI file:", error);
            }
        }

        // Clear the canvas
        function clearCanvas() {
            canvas.clear();
            saveState();
        }

        // Save initial state
        saveState();
    </script>

</body>
</html>
